#lang racket

(provide make-code-table encode decode)

(define char-freqs (λ (charseq)
  (define freq-hash (make-hash))
  (for ([char charseq])
    (if (hash-has-key? freq-hash char)
      (hash-update! freq-hash char (curry + 1))
      (hash-set! freq-hash char 1)))
  freq-hash))

(define char-segments (λ (freq-hash)
  (define total-char-count (foldl + 0 (hash-values freq-hash)))
  (define bound 0)
  (define segments (for/hash ([(char cnt) (in-hash freq-hash)])
    (define prob (/ cnt total-char-count))
    (define lower-bound bound)
    (set! bound (+ bound prob))
    (values char (cons lower-bound bound))))
  segments))

(define make-code-table (compose1 char-segments char-freqs))

(define encode (λ (input segments)
  (define lower 0)
  (define upper 1)
  (for ([char input])
    (match-define (cons lbound ubound) (hash-ref segments char))
    (define enc-lower (+ lower (* lbound (- upper lower))))
    (define enc-upper (+ lower (* ubound (- upper lower))))
    (set! lower enc-lower)
    (set! upper enc-upper))
  lower))
  
(define decode (λ (input text-len segments)
  (define out "")
  (define segment-list (hash->list segments))
  (for ([_ (in-range text-len)])
    (match-define (list char lbound ubound) (decode-lookup-char input segment-list))
    (set! out (~a out char))
    (set! input (/ (- input lbound) (- ubound lbound))))
  out))

(define decode-lookup-char (λ (encoded segment-list)
  (match-define (cons (cons char (cons lbound ubound)) tail) segment-list)
  (if (and (<= lbound encoded) (< encoded ubound))
    (list char lbound ubound)
    (decode-lookup-char encoded tail))))
